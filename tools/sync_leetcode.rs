use std::io::Write;
use std::path::Path;
use std::process::{Command, Stdio};
use std::{
    collections::{BTreeMap, HashSet},
    fs, io,
    path::PathBuf,
};

fn format_with_rustfmt(code: &str) -> String {
    let mut child = match Command::new("rustfmt")
        .arg("--emit=stdout")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
    {
        Ok(c) => c,
        Err(_) => return code.to_string(),
    };

    if let Some(stdin) = child.stdin.as_mut() {
        let _ = stdin.write_all(code.as_bytes());
    }

    let output = match child.wait_with_output() {
        Ok(o) => o,
        Err(_) => return code.to_string(),
    };

    if output.status.success() {
        String::from_utf8_lossy(&output.stdout).to_string()
    } else {
        code.to_string()
    }
}

struct Problem {
    number: u32,
    slug: String,
    title: String,
    category: String,
    level: String,
    percent: String,
    description: String,
    source: String,
}

#[derive(PartialEq)]
enum FileType {
    Index,
    Readme,
}

fn parse_range() -> Option<(Option<u32>, Option<u32>)> {
    let args: Vec<String> = std::env::args().skip(1).collect();
    match args.len() {
        0 => None,
        1 => args[0].parse::<u32>().ok().map(|to| (None, Some(to))),
        _ => {
            let a = args[0].parse::<u32>().ok()?;
            let b = args[1].parse::<u32>().ok()?;
            let (from, to) = if a <= b { (a, b) } else { (b, a) };
            Some((Some(from), Some(to)))
        }
    }
}

fn bucket_size(total: usize) -> u32 {
    match total {
        0..=50 => 10,
        51..=200 => 25,
        201..=500 => 50,
        _ => 100,
    }
}

fn main() -> io::Result<()> {
    let home = std::env::var("HOME").expect("HOME not set");
    let root = PathBuf::from(home).join("leetcode-rs");
    let solutions_dir = root.join("solutions");
    let range = parse_range();

    let mut problems = Vec::new();

    for entry in fs::read_dir(&solutions_dir)? {
        let path = entry?.path();
        if !path.is_file() {
            continue;
        }

        let file = match path.file_name().and_then(|s| s.to_str()) {
            Some(f) => f,
            None => continue,
        };

        if let Some((num, rest)) = file.split_once('.') {
            if !num.chars().all(|c| c.is_ascii_digit()) {
                continue;
            }
            if rest.ends_with(".rs") {
                let p = parse_problem(&path)?;
                if let Some((from, to)) = range {
                    if let Some(f) = from {
                        if p.number < f {
                            continue;
                        }
                    }
                    if let Some(t) = to {
                        if p.number > t {
                            continue;
                        }
                    }
                }
                problems.push(p);
            }
        }
    }

    problems.sort_by_key(|p| p.number);

    generate_analysis_lib(&root, &problems)?;
    generate_problem_readmes(&problems, &root, FileType::Readme)?;
    generate_problem_readmes(&problems, &root, FileType::Index)?;

    cleanup_orphan_readmes(&problems, &root)?;
    generate_index_readme(&problems, &root, FileType::Readme)?;
    generate_index_readme(&problems, &root, FileType::Index)?;

    Ok(())
}

fn parse_problem(path: &PathBuf) -> io::Result<Problem> {
    let content = fs::read_to_string(path)?;

    let mut category = String::new();
    let mut level = String::new();
    let mut percent = String::new();
    let mut desc = Vec::new();

    for line in content.lines() {
        let l = line.trim();
        if l.starts_with("// Category:") {
            category = l[12..].trim().to_string();
        } else if l.starts_with("// Level:") {
            level = l[9..].trim().to_string();
        } else if l.starts_with("// Percent:") {
            percent = l[11..].trim().to_string();
        } else if l.starts_with("//") {
            desc.push(
                l.trim_start_matches("//")
                    .trim_start_matches(" ")
                    .to_string(),
            );
        } else if l.starts_with("use ") || l.starts_with("impl ") {
            break;
        }
    }

    let file = path.file_name().unwrap().to_str().unwrap();
    let (num, slug) = file.split_once('.').unwrap();
    let slug = slug.strip_suffix(".rs").unwrap();

    Ok(Problem {
        number: num.parse().unwrap(),
        slug: slug.to_string(),
        title: title_case(slug),
        category,
        level,
        percent,
        description: desc.join("\n"),
        source: format!("solutions/{}.{}.rs", num, slug),
    })
}

fn generate_analysis_lib(root: &PathBuf, problems: &[Problem]) -> io::Result<()> {
    let src = root.join("src");
    fs::create_dir_all(&src)?;

    let mut out = String::new();
    out.push_str(
        "//! Analysis-only crate root.
//!
//! Auto-generated by sync_leetcode.
//! Enables rust-analyzer and IDE tooling only.

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(non_snake_case)]

mod solutions {
",
    );

    for p in problems {
        out.push_str(&format!("    include!(\"../{}\");\n", p.source));
    }

    out.push_str("}\n");
    fs::write(src.join("lib.rs"), out)
}

fn generate_problem_readmes(
    problems: &[Problem],
    root: &PathBuf,
    filetype: FileType,
) -> io::Result<()> {
    for (n, p) in problems.iter().enumerate() {
        let mut out = String::new();

        if filetype == FileType::Index {
            out.push_str(&format!("---\ntitle: {}\n---\n\n", p.title));
        }

        out.push_str(&format!("# {}. {}\n\n", p.number, p.title));
        out.push_str(&format!(
            "**Category:** {}\\\n**Difficulty:** {}\\\n**Acceptance:** {}\n\n",
            p.category, p.level, p.percent
        ));
        out.push_str(&format!(
            "**LeetCode:** [View on LeetCode](https://leetcode.com/problems/{}/)\n\n",
            p.slug
        ));

        out.push_str("\n\n## Problem\n\n");

        let mut section = "problem";
        let mut example_idx = 0;

        let mut in_code = false;
        let mut code_buffer = String::new();

        let mut constraint_lines: Vec<String> = Vec::new();
        let mut follow_up_line: Option<String> = None;

        let lines: Vec<&str> = p.description.lines().collect();

        for (idx, raw) in lines.iter().enumerate() {
            let line = raw.trim_start();
            let is_indented = raw.starts_with('\t') || raw.starts_with("    ");
            let next_line = lines.get(idx + 1).map(|l| l.trim()).unwrap_or("");
            let is_code = looks_like_code(line);

            /* ===== SECTION SWITCH ===== */

            if line.starts_with("Example") {
                if in_code {
                    let formatted = format_with_rustfmt(&code_buffer);
                    out.push_str("```rust\n");
                    out.push_str(&formatted);
                    out.push_str("```\n");
                    code_buffer.clear();
                    in_code = false;
                }

                if section == "constraints" {
                    render_constraints(&mut out, &constraint_lines, &follow_up_line);
                    constraint_lines.clear();
                    follow_up_line = None;
                }

                if section != "examples" {
                    out.push_str("\n\n## Examples\n\n");
                    section = "examples";
                }

                example_idx += 1;
                out.push_str(&format!("#### Example {}\n\n", example_idx));
                continue;
            }

            if line.starts_with("Constraints") {
                if in_code {
                    let formatted = format_with_rustfmt(&code_buffer);
                    out.push_str("```rust\n");
                    out.push_str(&formatted);
                    out.push_str("```\n");
                    code_buffer.clear();
                    in_code = false;
                }

                out.push_str("\n\n## Constraints\n\n");
                section = "constraints";
                continue;
            }

            /* ===== ENTER CODE SESSION ===== */

            if is_code && !in_code {
                in_code = true;
                code_buffer.clear();
            }

            if in_code {
                code_buffer.push_str(line);
                code_buffer.push('\n');
                continue;
            }

            /* ===== CONSTRAINT COLLECTION ===== */

            if section == "constraints" {
                if line.is_empty() {
                    continue;
                }

                if line.trim().to_lowercase().starts_with("follow") && line.contains(":") {
                    follow_up_line = Some(line.to_string());
                } else {
                    constraint_lines.push(raw.to_string());
                }
                continue;
            }

            /* ===== NORMAL TEXT ===== */

            if line.is_empty() {
                out.push('\n');
            } else {
                let rendered = if section == "examples" {
                    emphasize_example_labels(line)
                } else {
                    line.to_string()
                };

                if is_indented && !rendered.starts_with("-") {
                    out.push_str(&format!("- {}", rendered));
                } else {
                    out.push_str(&rendered);

                    if !next_line.is_empty() && !rendered.starts_with("-") {
                        out.push('\\');
                    }
                }

                out.push('\n');
            }
        }

        /* ===== FINAL FLUSH ===== */
        if section == "constraints" {
            render_constraints(&mut out, &constraint_lines, &follow_up_line);
        }

        if in_code && !code_buffer.is_empty() {
            let formatted = format_with_rustfmt(&code_buffer);
            out.push_str("\n```rust\n");
            out.push_str(&formatted);
            out.push_str("```\n");
        }

        out.push_str("\n\n## Source / Solution\n\n");

        match filetype {
            FileType::Readme => {
                out.push_str(&format!("[{}](../{})\n", p.source, p.source));
            }
            FileType::Index => {
                if let Some(code) = generate_solution_hint(&root.join(&p.source))? {
                    out.push_str("<details>\n<summary>Click to reveal solution hint</summary>\n\n");

                    out.push_str("{% highlight rust %}\n");
                    out.push_str(&code);
                    out.push_str("\n{% endhighlight %}\n");
                    out.push_str("\n</details>\n");
                }
            }
        }

        let suffix = if filetype == FileType::Index {
            ""
        } else {
            ".md"
        };
        out.push_str(&render_pagination(problems, n, suffix));

        out.push_str("\n---\n\n");
        out.push_str("<small>*Auto-generated by `sync_leetcode`. Manual changes may be overwritten.*</small>\n");

        match filetype {
            FileType::Readme => {
                let path = root.join(format!("problems/{:03}-{}.md", p.number, p.slug));
                fs::write(path, lint_markdown(&out))?;
            }
            FileType::Index => {
                let path = root
                    .clone()
                    .join(format!("docs/problems/{:03}-{}.md", p.number, p.slug));
                fs::write(path, lint_markdown(&out))?;
            }
        }
    }

    Ok(())
}

fn render_pagination(problems: &[Problem], index: usize, suffix: &str) -> String {
    let mut out = String::new();

    out.push_str("\n---\n\n");

    if index > 0 {
        let p = &problems[index - 1];
        out.push_str(
            &format!(
                "← [Previous](../problems/{:03}-{}{}) ",
                p.number, p.slug, suffix
            )
            .replace(" /)", "/)"),
        );
    }

    if index > 0 || index + 1 < problems.len() {
        out.push_str("· ");
    }

    if suffix.is_empty() {
        out.push_str("[Back to index](../)");
    } else {
        out.push_str("[Back to index](../README.md)");
    }

    if index + 1 < problems.len() {
        let n = &problems[index + 1];
        out.push_str(
            &format!(
                " · [Next](../problems/{:03}-{}{}) →",
                n.number, n.slug, suffix
            )
            .replace(" /)", "/)"),
        );
    }

    out.push_str("\n\n");

    out
}

fn render_constraints(out: &mut String, constraints: &[String], follow_up: &Option<String>) {
    if constraints.is_empty() && follow_up.is_none() {
        return;
    }

    for line in constraints {
        if !is_simple_constraint_line(line) {
            let emphasized = emphasize_constraint_line(line.trim());
            out.push_str("- ");
            out.push_str(&emphasized);
            out.push('\n');
        } else {
            out.push_str(line.trim());
            out.push('\n');
        }
    }

    if let Some(fu) = follow_up {
        out.push('\n');
        out.push_str("**Follow-up:**");
        out.push_str(&fu[10..]);
        out.push('\n');
    }
}

fn is_simple_constraint_line(line: &str) -> bool {
    let l = line.trim();

    if l.is_empty() {
        return false;
    }

    if l.starts_with("```")
        || l.starts_with("//")
        || l.starts_with('#')
        || l.contains('{')
        || l.contains('}')
        || l.contains(';')
    {
        return false;
    }

    if line.starts_with(' ') || line.starts_with('\t') {
        return false;
    }

    if l.len() > 120 {
        return false;
    }

    true
}

fn emphasize_constraint_line(line: &str) -> String {
    let mut out = String::new();
    let chars: Vec<char> = line.chars().collect();
    let mut i = 0;

    while i < chars.len() {
        let c = chars[i];

        // === Bold angka / batas numerik ===
        if c.is_ascii_digit() || (c == '-' && i + 1 < chars.len() && chars[i + 1].is_ascii_digit())
        {
            let start = i;
            i += 1;

            while i < chars.len() && (chars[i].is_ascii_digit() || chars[i] == '^') {
                i += 1;
            }

            let num: String = chars[start..i].iter().collect();
            out.push_str("**");
            out.push_str(&num);
            out.push_str("**");
            continue;
        }

        // === Italic identifier teknis (nums[i], nums.length, Node.val) ===
        if c.is_ascii_alphabetic() || c == '_' {
            let start = i;
            i += 1;

            while i < chars.len()
                && (chars[i].is_ascii_alphanumeric()
                    || chars[i] == '_'
                    || chars[i] == '.'
                    || chars[i] == '['
                    || chars[i] == ']')
            {
                i += 1;
            }

            let ident: String = chars[start..i].iter().collect();

            if ident.contains('.') || ident.contains('[') {
                out.push('*');
                out.push_str(&ident);
                out.push('*');
            } else {
                out.push_str(&ident);
            }

            continue;
        }

        // === Karakter lain ===
        out.push(c);
        i += 1;
    }

    out
}

fn cleanup_orphan_readmes(problems: &[Problem], root: &PathBuf) -> io::Result<()> {
    let dir = root.join("problems");
    if !dir.exists() {
        return Ok(());
    }

    let expected: HashSet<String> = problems
        .iter()
        .map(|p| format!("{:03}-{}.md", p.number, p.slug))
        .collect();

    for entry in fs::read_dir(&dir)? {
        let path = entry?.path();
        if let Some(name) = path.file_name().and_then(|s| s.to_str()) {
            if !expected.contains(name) {
                fs::remove_file(path)?;
            }
        }
    }

    Ok(())
}

fn generate_index_readme(
    problems: &[Problem],
    root: &PathBuf,
    filetype: FileType,
) -> io::Result<()> {
    let bucket = bucket_size(problems.len());

    let total = problems.len();
    let mut easy = 0;
    let mut medium = 0;
    let mut hard = 0;

    for p in problems {
        match p.level.as_str() {
            "Easy" => easy += 1,
            "Medium" => medium += 1,
            "Hard" => hard += 1,
            _ => {}
        }
    }

    let mut buckets: BTreeMap<u32, Vec<&Problem>> = BTreeMap::new();
    for p in problems {
        let start = ((p.number - 1) / bucket) * bucket + 1;
        buckets.entry(start).or_default().push(p);
    }

    let mut out = String::new();

    let mut ctx = "repository";
    let mut docs_str = "docs/";

    if filetype == FileType::Index {
        out.push_str("---\ntitle: leetcode-rs\n---\n\n");
        ctx = "site";
        docs_str = "";
    }

    out.push_str(&format!(
        "![leetcode-rs banner]({}assets/banner.png)\n\n",
        docs_str
    ));

    out.push_str("# LeetCode Solutions (Rust)\n\n");
    out.push_str(&format!(
        "This {0} contains a curated collection of LeetCode solutions written in Rust,\n\
with a focus on clarity, correctness, and maintainable documentation.\n\n\
The {0} is updated daily as part of a personal challenge to solve one\n\
LeetCode problem per day.\n\n",
        ctx
    ));

    if filetype == FileType::Readme {
        out.push_str(
            "> A browsable web version of this repository is available on the [project website](https://mzyui.github.io/leetcode-rs/).\n\n"
        );
    } else {
        out.push_str(
            "> This website is a rendered view of the [GitHub repository](https://github.com/mzyui/leetcode-rs).\n\n"
        );
    }

    out.push_str("## Statistics\n\n");
    out.push_str(&format!(
        "**Total Problems Solved:** {}\n\n\
| Difficulty | Count |\n\
|------------|-------|\n\
| Easy       | {}     |\n\
| Medium     | {}     |\n\
| Hard       | {}     |\n\n",
        total, easy, medium, hard
    ));

    out.push_str(
        "> This is a documentation-focused repository.  \n\
> Individual problems are documented in detail under the `problems/` directory.\n\n",
    );

    out.push_str("![Rust](https://img.shields.io/badge/language-Rust-orange)\n\n");

    out.push_str("## Quick Navigation\n\n");

    for (start, group) in &buckets {
        if !group.is_empty() {
            let end = start + bucket - 1;
            out.push_str(&format!(
                "- [Problems {}-{}](#problems-{}-{})\n",
                start, end, start, end
            ));
        }
    }

    for (start, group) in &buckets {
        let end = start + bucket - 1;
        out.push_str(&format!(
            "\n\n<a id=\"problems-{}-{}\"></a>\n## Problems {}-{}\n\n",
            start, end, start, end
        ));
        out.push_str("| # | Problem | Difficulty | Category |\n");
        out.push_str("|---|--------|------------|----------|\n");

        let mut g = group.clone();
        g.sort_by_key(|p| p.number);

        for p in g {
            match filetype {
                FileType::Readme => {
                    out.push_str(&format!(
                        "| {} | [{}](problems/{:03}-{}.md) | {} | {} |\n",
                        p.number, p.title, p.number, p.slug, p.level, p.category
                    ));
                }
                FileType::Index => {
                    out.push_str(&format!(
                        "| {} | [{}](problems/{:03}-{}) | {} | {} |\n",
                        p.number, p.title, p.number, p.slug, p.level, p.category
                    ));
                }
            }
        }
        out.push_str("\n[Back to top](#leetcode-solutions-rust)\n");
    }

    out.push_str("\n\n## Repository Structure\n\n");
    out.push_str(
        "```text\n\
leetcode-rs/\n\
├── docs/             # Auto-generated documentation\n\
├── solutions/        # Original Rust solution files (source of truth)\n\
├── problems/         # Auto-generated per-problem documentation\n\
├── src/              # Analysis-only crate root (rust-analyzer)\n\
├── tools/            # Synchronization tooling\n\
├── Cargo.toml        # Minimal Cargo manifest\n\
└── README.md         # Repository overview\n\
```\n",
    );

    out.push_str("\n\n## Tooling and Synchronization\n\n");
    out.push_str(
        "A custom synchronization tool (`sync_leetcode`) is used to keep solution\n\
files, documentation, and metadata in sync.\n\n\
```bash\n\
cd ~/leetcode-rs\n\
rustc tools/sync_leetcode.rs -O -o tools/sync_leetcode\n\
./tools/sync_leetcode\n\
./tools/sync_leetcode 100\n\
```\n",
    );

    out.push_str("\n\n## Scope and Design Goals\n\n");
    out.push_str(
        "- Readable and idiomatic Rust solutions\n\
- No execution or benchmarking\n\
- Deterministic, auto-generated documentation\n\
- Strong IDE support via rust-analyzer\n",
    );

    out.push_str("\n\n## Notes\n\n");
    out.push_str(
        "- `solutions/` is the single source of truth\n\
- Files under `problems/` and `src/` are auto-generated\n\
- Manual edits to generated files will be overwritten\n",
    );

    out.push_str("\n\n## Credits\n\n");
    out.push_str(
        "- LeetCode platform\n\
- leetcode-cli by clearloop ([GitHub repository](https://github.com/clearloop/leetcode-cli))\n\
- Tooling (`sync_leetcode`) was developed with assistance from an AI language model (ChatGPT, GPT-5).\n\n",
    );

    out.push_str("\n\n## Disclaimer\n\n");
    out.push_str(
        "This repository is independently maintained and is not affiliated with, endorsed by,\n\
or sponsored by LeetCode. All problem descriptions remain the property of their\n\
respective owners.\n",
    );

    out.push_str("\n---\n\n");
    out.push_str(
        "<small>*Auto-generated by `sync_leetcode`. Manual changes may be overwritten.*</small>\n",
    );

    match filetype {
        FileType::Readme => fs::write(root.join("README.md"), out),
        FileType::Index => fs::write(root.join("docs/index.md"), out),
    }
}

fn title_case(slug: &str) -> String {
    slug.split('-')
        .map(|w| {
            let mut c = w.chars();
            match c.next() {
                None => String::new(),
                Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}

fn looks_like_code(line: &str) -> bool {
    let l = line.trim();

    l.starts_with("#[")
        || l.starts_with("pub ")
        || l.starts_with("struct ")
        || l.starts_with("impl ")
        || l.starts_with("fn ")
        || l.starts_with("enum ")
        || l.starts_with("use ")
}

fn lint_markdown(input: &str) -> String {
    let mut out = String::new();
    let mut prev_blank = false;

    for line in input.lines() {
        let trimmed = line.trim_end();
        let blank = trimmed.is_empty();

        if blank && prev_blank {
            continue;
        }

        out.push_str(trimmed);
        out.push('\n');
        prev_blank = blank;
    }

    out
}

fn emphasize_example_labels(line: &str) -> String {
    if let Some(rest) = line.strip_prefix("Input:") {
        format!("- **Input:**{}", rest)
    } else if let Some(rest) = line.strip_prefix("Output:") {
        format!("- **Output:**{}", rest)
    } else if let Some(rest) = line.strip_prefix("Explanation:") {
        format!("- **Explanation:**{}", rest)
    } else {
        format!("  {line}")
    }
}

fn strip_rust_comments(src: &str) -> String {
    let mut out = String::new();
    let mut chars = src.chars().peekable();

    let mut in_block_comment = false;
    let mut in_string = false;

    while let Some(c) = chars.next() {
        if in_block_comment {
            if c == '*' && chars.peek() == Some(&'/') {
                chars.next();
                in_block_comment = false;
            }
            continue;
        }

        if in_string {
            out.push(c);
            if c == '"' {
                in_string = false;
            }
            continue;
        }

        if c == '"' {
            in_string = true;
            out.push(c);
            continue;
        }

        if c == '/' {
            match chars.peek() {
                Some('/') => {
                    // line comment → skip till newline
                    while let Some(nc) = chars.next() {
                        if nc == '\n' {
                            out.push('\n');
                            break;
                        }
                    }
                    continue;
                }
                Some('*') => {
                    chars.next();
                    in_block_comment = true;
                    continue;
                }
                _ => {}
            }
        }

        out.push(c);
    }

    out
}

fn extract_solution_impl(src: &str) -> Option<String> {
    let mut lines = src.lines();
    let mut buf = String::new();
    let mut in_impl = false;
    let mut brace_depth = 0;

    while let Some(line) = lines.next() {
        if !in_impl {
            if line.trim_start().starts_with("impl Solution") {
                in_impl = true;
            } else {
                continue;
            }
        }

        if in_impl {
            brace_depth += line.matches('{').count() as isize;
            brace_depth -= line.matches('}').count() as isize;

            buf.push_str(line);
            buf.push('\n');

            if brace_depth == 0 {
                break;
            }
        }
    }

    if buf.is_empty() { None } else { Some(buf) }
}

fn generate_solution_hint(solution_path: &Path) -> io::Result<Option<String>> {
    let src = fs::read_to_string(solution_path)?;
    let no_comments = strip_rust_comments(&src);

    if let Some(code) = extract_solution_impl(&no_comments) {
        Ok(Some(code.trim().to_string()))
    } else {
        Ok(None)
    }
}
