---
title: Longest Palindromic Substring
---

# 5. Longest Palindromic Substring

**Category:** algorithms\
**Difficulty:** Medium\
**Acceptance:** 36.97404%

**LeetCode:** [View on LeetCode](https://leetcode.com/problems/longest-palindromic-substring/)

## Problem

Given a string s, return the longest palindromic substring in s.

## Examples

#### Example 1

- **Input:** s = "babad"
- **Output:** "bab"
- **Explanation:** "aba" is also a valid answer.

#### Example 2

- **Input:** s = "cbbd"
- **Output:** "bb"

## Constraints

- **1** <= *s.length* <= **1000**
- s consist of only digits and English *letters.*

## Source / Solution

<details>
<summary>Click to reveal solution hint</summary>

{% highlight rust %}
impl Solution {
    pub fn longest_palindrome(s: String) -> String {
        let n = s.len();
        if n == 0 {
            return String::new();
        }

        let mut t = Vec::with_capacity(2 * n + 1);
        for c in s.chars() {
            t.push('#');
            t.push(c);
        }
        t.push('#');

        let m = t.len();
        let mut p = vec![0; m];
        let (mut c, mut r) = (0, 0);
        let (mut max_len, mut idx) = (0, 0);

        for i in 0..m {
            if i < r {
                p[i] = p[2 * c - i].min(r - i);
            }
            while i + p[i] + 1 < m && i > p[i] && t[i + p[i] + 1] == t[i - p[i] - 1] {
                p[i] += 1;
            }
            if i + p[i] > r {
                c = i;
                r = i + p[i];
            }
            if p[i] > max_len {
                max_len = p[i];
                idx = i;
            }
        }

        let start = (idx - max_len) / 2;
        s[start..start + max_len].to_string()
    }
}
{% endhighlight %}

</details>

---

<div align="center">

← [Previous](../problems/004-median-of-two-sorted-arrays) · [Back to index](../) · [Next](../problems/006-zigzag-conversion) →

</div>

---

<small>*Auto-generated by `sync_leetcode`. Manual changes may be overwritten.*</small>
