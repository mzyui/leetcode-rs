---
title: Regular Expression Matching
---

# 10. Regular Expression Matching

**Category:** algorithms\
**Difficulty:** Hard\
**Acceptance:** 30.183533%

**LeetCode:** [View on LeetCode](https://leetcode.com/problems/regular-expression-matching/)

## Problem

Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:

- '.' Matches any single character.​​​​
- '*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

## Examples

#### Example 1

- **Input:** s = "aa", p = "a"
- **Output:** false
- **Explanation:** "a" does not match the entire string "aa".

#### Example 2

- **Input:** s = "aa", p = "a*"
- **Output:** true
- **Explanation:** '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".

#### Example 3

- **Input:** s = "ab", p = ".*"
- **Output:** true
- **Explanation:** ".*" means "zero or more (*) of any character (.)".

## Constraints

- **1** <= *s.length* <= **20**
- **1** <= *p.length* <= **20**
- s contains only lowercase English *letters.*
- p contains only lowercase English letters, '.', and '*'.
- It is guaranteed for each appearance of the character '*', there will be a previous valid character to *match.*

## Source / Solution

<details>
<summary>Click to reveal solution hint</summary>

{% highlight rust %}
impl Solution {
    pub fn is_match(s: String, p: String) -> bool {
        let s = s.as_bytes();
        let p = p.as_bytes();
        let mut memo = [[-1i8; 21]; 21];
        Self::dfs(0, 0, s, p, &mut memo)
    }

    fn dfs(
        i: usize,
        j: usize,
        s: &[u8],
        p: &[u8],
        memo: &mut [[i8; 21]; 21],
    ) -> bool {
        if memo[i][j] != -1 {
            return memo[i][j] == 1;
        }

        let ans = if j == p.len() {
            i == s.len()
        } else {
            let first_match =
                i < s.len() && (s[i] == p[j] || p[j] == b'.');

            if j + 1 < p.len() && p[j + 1] == b'*' {
                Self::dfs(i, j + 2, s, p, memo)
                    || (first_match && Self::dfs(i + 1, j, s, p, memo))
            } else {
                first_match && Self::dfs(i + 1, j + 1, s, p, memo)
            }
        };

        memo[i][j] = if ans { 1 } else { 0 };
        ans
    }
}
{% endhighlight %}

</details>

---

← [Previous](../problems/009-palindrome-number) · [Back to index](../)

---

<small>*Auto-generated by `sync_leetcode`. Manual changes may be overwritten.*</small>
